# 沙箱安全机制

## 定义:

自定义String类，但是在加载自定义String类的时候会率先使用引导类加载器加载，
而引导类加载器在加载过程中会先加载jdk自带的文件（rt.jar包中的java\lang\String.class）,
报错信息说没有main方法就是因为加载的是rt.jar包中的String类。
这样可以保证对java核心源代码的保护，这就是沙箱安全机制.

## 类比举例

#### 我们在读写U盘信息时可以用360沙箱，防止U盘内的病毒等对沙箱外的系统构成污染

## 其他

#### 在jvm中表示两个class对象是否为同一个类存在的两个必要条件

- 类的完整类名必须一致，包括包名
- 加载这个类的ClassLoader（指ClassLoader实例对象）必须相同


  换句话说，在jvm中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的.

### 对类加载器的引用

JVM必须知道一个类型是有启动类加载器加载的还是由用户类加载器加载的。如果一个类型由用户类加载器加载的，那么jvm会将这个类加载器的一个引用作为类型信息的会议部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM需要保证两个类型的加载器是相同的。

### 类的主动使用和被动使用

​	java程序对类的使用方式分为：主动使用和被动使用

- 主动使用，分为七种情况

  创建类的实例
  访问某各类或接口的静态变量，或者对静态变量赋值
  调用类的静态方法
  反射 比如Class.forName(com.dsh.jvm.xxx)
  初始化一个类的子类
  java虚拟机启动时被标明为启动类的类
  JDK 7 开始提供的动态语言支持：
  java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化

- 除了以上七种情况，其他使用java类的方式都被看作是对类的被动使用，都不会导致类的初始化。
